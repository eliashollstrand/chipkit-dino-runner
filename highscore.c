/* 
Authors: 
Elias Hollstrand,
Mattias Kvist

Date: TODO

For copyright and licensing, see file COPYING 
*/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <pic32mx.h>

uint8_t highscore;
uint8_t score = 0;
static int JUMP_DELAY = 1;

#define EEPROM_WRITE 0xA0 // 1010 0000
#define EEPROM_READ 0xA1 // 1010 0001
// #define EEPROM_MEM_ADD 0x100
#define SCORE_ADDRESS 0x0000
#define EEPROM_ADDR 0x50 

void score_display() {
     display_string(1, itoaconv((int)score));
     display_string(3, itoaconv((int)highscore));
     display_update();
}

// void read_highscore() {
//     // Get the high score from EEPROM and store in highscore variable
//     i2c_start();
//     i2c_send(EEPROM_WRITE);
//     i2c_send(EEPROM_MEM_ADD >> 8);
//     i2c_send(EEPROM_MEM_ADD & 0xFF);
//     i2c_restart();
//     i2c_send(EEPROM_READ);
//     highscore = i2c_recv();
//     i2c_ack();
//     i2c_nack();
//     i2c_stop();
// }

// void write_highscore() {
//     // Write new highscore to EEPROM
//     i2c_start(); // Start I2C communication
//     i2c_send(EEPROM_WRITE); // Send the write command to the EEPROM
//     i2c_ack(); // Send an acknowledgment signal

//     // Send the high byte of the EEPROM address
//     i2c_send(EEPROM_MEM_ADD >> 8);
//     i2c_ack(); // Send an acknowledgment signal
    
//     // Send the low byte of the EEPROM address
//     i2c_send(EEPROM_MEM_ADD & 0xFF);
//     i2c_ack(); // Send an acknowledgment signal

//     i2c_send(score); // Send the score to the EEPROM
//     i2c_ack(); // Send an acknowledgment signal

//     i2c_stop(); // Stop I2C communication
// }

void writeToEEPROM(uint8_t data, uint16_t address) {
    i2c_start(); // Start I2C communication

    // Send the control byte (device address + write command)
    i2c_send(EEPROM_READ);
    if (!i2c_ack()) {
        display_string(0, "Error");
    }

    if(PIC32_IRQ_I2C1B) {
        display_string(0, "Error");
    }

    // Send the high byte of the EEPROM address
    i2c_send(address >> 8);
    if (!i2c_ack()) {
        display_string(0, "Error");
    }

    // Send the low byte of the EEPROM address
    i2c_send(address & 0xFF);
    if (!i2c_ack()) {
        display_string(0, "Error");
    }

    i2c_send(data); // Send the data to the EEPROM
    if (!i2c_ack()) {
        display_string(0, "Error");
    }

    i2c_stop(); // Stop I2C communication

    if(PIC32_IRQ_I2C1S) {
        display_string(1, "Error");
    }
    if(PIC32_IRQ_I2C1M) {
        display_string(2, "Error");
    }
}

void readFromEEPROM(uint16_t address) {
    uint8_t data = 0;
    i2c_start(); // Start I2C communication

    // Send the control byte (device address + write command)
    i2c_send(EEPROM_WRITE);
    if (!i2c_ack()) {
        display_string(0, "Error");
        display_update();
    }

    // Send the high byte of the EEPROM address
    i2c_send(address >> 8);
    if (!i2c_ack()) {
        display_string(0, "Error");
        display_update();
    }

    // Send the low byte of the EEPROM address
    i2c_send(address & 0xFF);
    if (!i2c_ack()) {
        display_string(0, "Error");
        display_update();
    }

    i2c_restart(); // Restart I2C communication

    // Send the control byte (device address + read command)
    i2c_send(EEPROM_READ);
    if (!i2c_ack()) {
        display_string(0, "Error");
        display_update();
    }

    highscore = i2c_recv(); // Receive the data from the EEPROM
    i2c_nack();
    i2c_stop(); // Stop I2C communication

    // if(PIC32_IRQ_I2C1B || PIC32_IRQ_I2C1S || PIC32_IRQ_I2C1M) {
    // display_string(0, "Error");
    // }
}

void score_update() {
    score++;
    if(score > 200) {
        // Update the highscore
        highscore = score;
        // write_highscore();
        writeToEEPROM(score, SCORE_ADDRESS);
    }
    score_display();
}

/* Interrupt Service Routine */
void user_isr( void ) {
    if (IFS(1) & 0x1){
        IFSCLR(1) = 0x1;
        score_update();
    }
}

void score_init() {
    TRISD = TRISD | 0x80;
    CNCON = 0x8000;
    
    IECSET(0) = 0x80000;   
    IECSET(0) = 0x80000;   
    IECSET(1) = 0x1;
    IPCSET(4) = 0x1c000000;
    IPCSET(6) = 0x1C0000;
    CNEN = 0x10000;

    // Set up i2c
	I2C1CON = 0x0;
	/* I2C Baud rate should be less than 400 kHz, is generated by dividing
	the 40 MHz peripheral bus clock down */
	I2C1BRG = 0x0C2;
	I2C1STAT = 0x0;
	I2C1CONSET = 1 << 13; // SIDL = 1
	I2C1CONSET = 1 << 15; // ON = 1
    I2C1ADD = 1010000;
 
    // Enable global interrupts
    enable_interrupt();

    // Write an initial value into SCORE_ADDRESS
    writeToEEPROM(100, SCORE_ADDRESS);
    
    // Get the high score from EEPROM and store in highscore variable
    // read_highscore();
    readFromEEPROM(SCORE_ADDRESS);

    // Display score and current highscore
    score_display();
}




